[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesn’t specify an explicit image, the first image in the post will be used in the listing page of posts."
  },
  {
    "objectID": "posts/post-with-code/index.html",
    "href": "posts/post-with-code/index.html",
    "title": "Post With Code",
    "section": "",
    "text": "This is a post with executable code."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "How to Prepare for Coding Interviews Without Grinding Forever",
    "section": "",
    "text": "If you search online for advice on preparing for coding interviews, one recommendation appears again and again: “Just do more LeetCode.” LeetCode is a popular platform that hosts thousands of programming problems, commonly used by candidates preparing for technical interviews in software engineering and data-related roles.\nThis advice naturally leads to a deceptively simple question: how many LeetCode problems do you actually need to do to pass a coding interview? Is it 50? 100? 500? Or is there no meaningful number at all?\nIn this post, we’ll explore why this question matters, why the answer is more nuanced than most people expect, and how a data-driven mindset can help us think about interview preparation more effectively."
  },
  {
    "objectID": "index.html#how-many-leetcode-problems-do-you-really-need-to-pass-a-coding-interview",
    "href": "index.html#how-many-leetcode-problems-do-you-really-need-to-pass-a-coding-interview",
    "title": "How to Prepare for Coding Interviews Without Grinding Forever",
    "section": "",
    "text": "If you search online for advice on preparing for coding interviews, one recommendation appears again and again: “Just do more LeetCode.” LeetCode is a popular platform that hosts thousands of programming problems, commonly used by candidates preparing for technical interviews in software engineering and data-related roles.\nThis advice naturally leads to a deceptively simple question: how many LeetCode problems do you actually need to do to pass a coding interview? Is it 50? 100? 500? Or is there no meaningful number at all?\nIn this post, we’ll explore why this question matters, why the answer is more nuanced than most people expect, and how a data-driven mindset can help us think about interview preparation more effectively."
  },
  {
    "objectID": "index.html#why-do-we-want-to-know-this",
    "href": "index.html#why-do-we-want-to-know-this",
    "title": "How to Prepare for Coding Interviews Without Grinding Forever",
    "section": "Why Do We Want to Know This?",
    "text": "Why Do We Want to Know This?\nPreparing for coding interviews is time-consuming and stressful. Many candidates are students or working professionals juggling full-time jobs, classes, or personal responsibilities. Time spent grinding practice problems often comes at the expense of rest, social life, or other learning opportunities.\nFrom a data science perspective, this is a classic resource allocation problem: how do we spend limited time to maximize the probability of success? If doing 300 problems is not significantly better than doing 120 problems well, then blindly increasing volume is inefficient.\nThere is also a strong psychological component. Candidates frequently compare themselves to others online who claim to have solved hundreds or even thousands of problems. This creates anxiety and the false impression that success is primarily about endurance rather than understanding."
  },
  {
    "objectID": "index.html#what-are-coding-interviews-actually-testing",
    "href": "index.html#what-are-coding-interviews-actually-testing",
    "title": "How to Prepare for Coding Interviews Without Grinding Forever",
    "section": "What Are Coding Interviews Actually Testing?",
    "text": "What Are Coding Interviews Actually Testing?\nBefore answering how many problems are “enough,” it helps to clarify what coding interviews are designed to evaluate.\nDespite appearances, interviews are not memory tests. Interviewers are rarely checking whether you have seen the exact problem before. Instead, they are assessing:\nHow you break down a problem\nHow you communicate your thinking\nHow you handle edge cases and mistakes\nWhether you can adapt known ideas to new situations\nIn other words, interviews test problem-solving ability under uncertainty. LeetCode is simply a training dataset—not the objective itself."
  },
  {
    "objectID": "index.html#so-how-many-problems-are-enough",
    "href": "index.html#so-how-many-problems-are-enough",
    "title": "How to Prepare for Coding Interviews Without Grinding Forever",
    "section": "So… How Many Problems Are Enough?",
    "text": "So… How Many Problems Are Enough?\nThere is no universal number that guarantees success. Different companies, roles, and interviewers emphasize different skills. Someone with a strong computer science background may need fewer problems than someone encountering these concepts for the first time.\nThat said, based on common reports from candidates and interviewers, many people pass coding interviews after completing roughly 100 to 200 well-chosen LeetCode problems.\nThis range is not special because of the number itself. It works because it is often sufficient to expose candidates to the most common problem patterns that appear in interviews. Once these patterns are understood, new problems become variations rather than entirely new challenges."
  },
  {
    "objectID": "index.html#the-trap-of-counting-problems",
    "href": "index.html#the-trap-of-counting-problems",
    "title": "How to Prepare for Coding Interviews Without Grinding Forever",
    "section": "The Trap of Counting Problems",
    "text": "The Trap of Counting Problems\nA common mistake is treating LeetCode progress as a scoreboard: more problems equals better preparation. This is an example of optimizing the wrong metric.\nFrom a data science standpoint, this is similar to overfitting. You may perform extremely well on the training data (solving many familiar problems) but fail to generalize to new data (unseen interview questions). Interview success depends on generalization, not memorization.\nTwo candidates who have both solved 150 problems may be at very different levels. One may recognize patterns and explain solutions clearly, while the other may rely on vague recollection and struggle to adapt."
  },
  {
    "objectID": "index.html#quality-vs.-quantity-new-problems-or-re-solving-old-ones",
    "href": "index.html#quality-vs.-quantity-new-problems-or-re-solving-old-ones",
    "title": "How to Prepare for Coding Interviews Without Grinding Forever",
    "section": "Quality vs. Quantity: New Problems or Re-solving Old Ones?",
    "text": "Quality vs. Quantity: New Problems or Re-solving Old Ones?\nThis leads to an important strategic question: should you keep doing new problems, or should you go back and re-solve old ones?\nMany candidates underestimate the value of re-solving. When you revisit a problem after some time and can:\nSolve it more quickly\nExplain it clearly in plain language\nModify the solution when constraints change\nyou are demonstrating real understanding. This is exactly the skill interviews reward.\nIn contrast, constantly chasing new problems can give the illusion of progress while reinforcing shallow familiarity. In learning science, this is known as the difference between recognition (“this looks familiar”) and recall (“I can do this from scratch”)."
  },
  {
    "objectID": "index.html#the-role-of-patterns-without-the-jargon",
    "href": "index.html#the-role-of-patterns-without-the-jargon",
    "title": "How to Prepare for Coding Interviews Without Grinding Forever",
    "section": "The Role of Patterns (Without the Jargon)",
    "text": "The Role of Patterns (Without the Jargon)\nOne reason LeetCode works at all is that many problems follow a small set of recurring ideas, often called patterns. A pattern is simply a reusable way of approaching a problem.\nFor example:\nSome problems involve scanning through a list efficiently\nSome involve breaking a big problem into smaller subproblems\nOthers involve exploring multiple possibilities and choosing the best one\nYou don’t need to memorize fancy names to benefit from this. What matters is recognizing that different-looking problems often share the same underlying structure.\nFrom a data science perspective, patterns are like features. Once you learn which features matter, the problem becomes much easier to model—even when the surface details change."
  },
  {
    "objectID": "index.html#a-more-effective-preparation-strategy",
    "href": "index.html#a-more-effective-preparation-strategy",
    "title": "How to Prepare for Coding Interviews Without Grinding Forever",
    "section": "A More Effective Preparation Strategy",
    "text": "A More Effective Preparation Strategy\nInstead of asking “How many problems should I do?”, a more productive question is:\nWhich ideas do I understand well enough to apply in new situations?\nAn effective strategy often looks like this:\nIdentify a core set of common problem types\nSolve a representative sample of problems for each type\nRevisit problems after a delay and explain them out loud\nPractice under mild time pressure to simulate interviews\nThis approach emphasizes depth over breadth and aligns closely with how learning transfers to real interviews."
  },
  {
    "objectID": "index.html#why-online-advice-can-be-misleading",
    "href": "index.html#why-online-advice-can-be-misleading",
    "title": "How to Prepare for Coding Interviews Without Grinding Forever",
    "section": "Why Online Advice Can Be Misleading",
    "text": "Why Online Advice Can Be Misleading\nMany blog posts and forum answers suffer from survivorship bias. We tend to hear from people who succeeded, not from those who used the same strategy and failed. Someone who solved 600 problems and got hired may attribute success to volume, even if fewer problems would have sufficed.\nAs data scientists, we should be cautious about drawing conclusions from anecdotal evidence without knowing the full population."
  },
  {
    "objectID": "index.html#final-takeaway",
    "href": "index.html#final-takeaway",
    "title": "How to Prepare for Coding Interviews Without Grinding Forever",
    "section": "Final Takeaway",
    "text": "Final Takeaway\nThere is no magic number of LeetCode problems that guarantees interview success. For most people, the effective range is far lower than the internet suggests.\nWhat matters is not how many problems you’ve completed, but whether you can:\nRecognize underlying patterns\nExplain your reasoning clearly\nAdapt your approach when constraints change\nIn short, understanding beats grinding. If you approach interview preparation with the same mindset you would apply to a data science problem—optimizing for signal, not noise—you’ll not only prepare more efficiently, but also with far less stress.\nAnd that, ultimately, is the real advantage."
  }
]